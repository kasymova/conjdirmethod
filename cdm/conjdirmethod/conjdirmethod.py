import math
from functools import reduce

from sympy import symbols
from sympy.abc import s
from sympy.matrices import Matrix, hessian
from sympy.parsing.sympy_parser import parse_expr

ROUNDING_NUMBER = 3  # число знаков, до которого округлять (только при выводе, считает точно)
MAX_ITER = 20  # максимальное число итераций

NUMBER_OF_VARS = 2  # число переменных
x_vars = symbols('x1:%d' % (NUMBER_OF_VARS + 1))  # создаем эти переменные

func = '(1-x1)**2 + 100*(x2-x1**2)**2'  # исходная функция
func = parse_expr(func)  # создаем ее

init_vector = [-1, 0]  # начальный вектор
init_vector = Matrix(init_vector)  # относим его к классу матриц

EPS = 0.01  # погрешность

listmerge = lambda s: reduce(lambda d, el: d.extend(el) or d, s, [])  # системная функция для слияния списков


def rounding_vectors(vector):  # Функция для округления векторов (только при выводе)
    vector = list(vector.evalf())
    return [round(el, ROUNDING_NUMBER) for el in vector]


def f_s(point, f):  # функция для подстановки аргумента в одномерную функцию
    """
    Принимает:
    f - функция от одной переменной f(s), которая получилась после подстановки аргументов в иходную функцию
    point - точка (число), которую необходимо подставить вместо s
    Возвращает:
    Значение функции (число) f(s) в точке point
    """
    return f.subs(s, point)


def f(point):  # функция для подстановки аргументов в исходную функцию
    """
    Принимает:
    point - точка (числовой вектор размером NUMBER_OF_VARS), которую необходимо подставить в исходную функцию
    Возвращает:
    f (число) - значение исходной функции в точке point
    """
    f = func
    for i in range(NUMBER_OF_VARS):
        f = f.subs(x_vars[i], point[i])
    return f


def golden_ratio(f):  # Метод золотого сечения
    """
    Принимает:
    f - функция от одной переменной f(s), которая получилась после подстановки аргументов в иходную функцию
    Возвращает:
    answer (число) - средняя точка на интервале (a, b)
    """
    a = -50  # границы интервала поиска
    b = 50
    PHI = (math.sqrt(5) - 1) / 2
    alpha = PHI * a + (1 - PHI) * b
    beta = (1 - PHI) * a + PHI * b

    while abs(b - a) > EPS:  # основной цикл
        if f_s(alpha, f) > f_s(beta, f):  # сравниваем значение функции в точках alpha и beta
            a = alpha
            alpha = beta
            beta = a + PHI * (b - a)
        else:
            b = beta
            beta = alpha
            alpha = a + (1 - PHI) * (b - a)

    answer = (a + b) / 2
    return answer


def dichotomy(f):  # Метод дихотомии
    """
    Принимает:
    f - функция от одной переменной f(s), которая получилась после подстановки аргументов в иходную функцию
    Возвращает:
    answer (число) - средняя точка на интервале (a, b)
    """
    a = -50  # границы интервала поиска
    b = 50
    delta = EPS / 2

    while abs(b - a) > EPS:  # основной цикл
        x1 = (a + b - delta) / 2
        x2 = (a + b + delta) / 2
        if f_s(x1, f) <= f_s(x2, f):  # сравниваем значение функции в точках alpha и beta
            b = x2
        else:
            a = x1

    answer = (a + b) / 2
    return answer


def conjdirmethod(method):  # Метод сопряженных направлений
    """
    Принимает:
    method (число) - метод, с помощью которого необходимо решить одномерную задачу минимиации
    1 - Метод золотого сечения
    2 - Метод дихотомии
    Возвращает:
    x (вектор) - точка минимума исходной функции
    """

    def solve(f):  # Вспомогательная функция
        """
        Функция, вызывающая метод дихотомии либо метод золотого сечения для решения одномерной задачи минимизации
        в зависимости от параметра method
        Принимает функцию от одного параметра f(s), которую необходимо минимизировать одним из методов
        """
        if method == 1:
            return golden_ratio(f)
        elif method == 2:
            return dichotomy(f)

    H = hessian(func, x_vars)  # находим матрицу Гессе исходной функции

    v = listmerge([el[2] for el in H.eigenvects()])  # находим собственные векторы матрицы Гессе
    # v = [el.evalf(ROUNDING_NUMBER) for el in v] # округляем собственные векторы

    x_0 = init_vector  # в качестве x_0 берем начальный вектор
    i = 0  # счетчик числа итераций

    # Внешний цикл - отвечает за число итераций, работает до тех пор, пока норма разности x и x0 больше EPS
    while True:
        i += 1
        print('\nИтерация ' + str(i) + ':')
        print('\tШаг 1:')

        # В качестве направления выбираем первый собственный вектор матрицы Гессе, считаем
        # его в точке x_0 (так как у функций, порядок которых выше, чем 2, матрица Гессе - переменная, зависящая
        # в общем случае от всех переменных x1, x2, ... и, следовательно, ее собственные векторы тоже переменные)
        # Если матрица Гессе состоит из констант, то никакой подстановки не произойдет
        d = [v[0].subs({x_vars[k]: x_0[k] for k in range(NUMBER_OF_VARS)})]

        x = x_0 + s * d[0]
        S = solve(f(list(x)))  # Находим S из решения задачи одномерной минимизации
        x = x.subs(s, S)  # Подставляем S в x
        print('\t\tx = ', rounding_vectors(x))

        # Второй цикл - отвечает за количество дальнейших шагов (2, 3, ...), которое зависит от числа переменных
        for j in range(1, NUMBER_OF_VARS):
            print('\tШаг ' + str(j + 1) + ':')

            # Находим y0 как x + (j+1)-ый (2-ой, 3-ий) собственный вектор матрицы Гессе,
            # аналогично считаем его в точке x_0
            y0 = x + v[j].subs({x_vars[k]: x_0[k] for k in range(NUMBER_OF_VARS)})

            y = y0  # для дальнейшего суммирования

            # Внутренний цикл для последовательной минимизации y по направлениям d0, d1, ...
            for k in range(0, j):
                y = y + s * d[k]
                S = solve(f(list(y)))  # Находим S из решения задачи одномерной минимизации
                y = y.subs(s, S)  # Подставляем S в y
            print('\t\ty = ', rounding_vectors(y))

            d.append(x - y)  # Находим следующее d как x - y

            x = x + s * d[j]
            S = solve(f(list(x)))  # Находим S из решения задачи одномерной минимизации
            x = x.subs(s, S)  # Подставляем S в y
            print('\t\tx = ', rounding_vectors(x))

        # Условие выхода из внешнего цикла - если норма разности x и x_0 становится меньше EPS
        if (x - x_0).norm() <= EPS:
            break
        # Условие выхода из внешнего цикла - если привышено максимальное число итерации (вдруг начало расходиться)
        if i > MAX_ITER:
            break
        # Полагаем x как x_0 для следующей итерации
        x_0 = x

    return x


print('Исходная функция: ', func)

# Вызываем метод сопряженных направлений, передаем параметр method, равный
# 1 - Метод золотого сечения
# 2 - Метод дихотомии
min_x = conjdirmethod(1)

print('\nОтвет: x_min = ', rounding_vectors(min_x))
